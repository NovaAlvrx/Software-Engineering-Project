# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    userId: _int
    fName: _str
    lName: _str
    email: _str
    password: _str
    role: 'enums.Role'
    profile: Optional['models.UserProfile'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class UserProfile(bases.BaseUserProfile):
    """Represents a UserProfile record"""

    userId: _int
    profile_picture: Optional[_str] = None
    general_location: Optional[_str] = None
    user: Optional['models.User'] = None
    posts: Optional[List['models.Post']] = None
    likes: Optional[List['models.Like']] = None
    comments: Optional[List['models.Comment']] = None
    skills: Optional[List['models.Skill']] = None
    targetSkills: Optional[List['models.TargetSkill']] = None
    sentMessages: Optional[List['models.Message']] = None
    receivedMessages: Optional[List['models.Message']] = None
    sentExchanges: Optional[List['models.Exchange']] = None
    receivedExchanges: Optional[List['models.Exchange']] = None
    reviewsGiven: Optional[List['models.Review']] = None
    reviewsReceived: Optional[List['models.Review']] = None
    searchHistories: Optional[List['models.SearchHistory']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserProfileKeys']] = None,
        exclude: Optional[Iterable['types.UserProfileKeys']] = None,
        required: Optional[Iterable['types.UserProfileKeys']] = None,
        optional: Optional[Iterable['types.UserProfileKeys']] = None,
        relations: Optional[Mapping['types.UserProfileRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserProfileKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserProfile_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserProfile_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserProfile_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserProfile_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserProfile_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserProfile_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserProfile', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserProfile / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserProfile',
            }
        )
        _created_partial_types.add(name)


class Post(bases.BasePost):
    """Represents a Post record"""

    postId: _int
    userId: _int
    description: _str
    img: _str
    createdAt: datetime.datetime
    user: Optional['models.UserProfile'] = None
    likes: Optional[List['models.Like']] = None
    comments: Optional[List['models.Comment']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PostKeys']] = None,
        exclude: Optional[Iterable['types.PostKeys']] = None,
        required: Optional[Iterable['types.PostKeys']] = None,
        optional: Optional[Iterable['types.PostKeys']] = None,
        relations: Optional[Mapping['types.PostRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PostKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Post_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Post_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Post_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Post_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Post_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Post_relational_fields:
                        raise errors.UnknownRelationalFieldError('Post', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Post / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Post',
            }
        )
        _created_partial_types.add(name)


class Like(bases.BaseLike):
    """Represents a Like record"""

    likeId: _int
    postId: _int
    userId: _int
    post: Optional['models.Post'] = None
    user: Optional['models.UserProfile'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LikeKeys']] = None,
        exclude: Optional[Iterable['types.LikeKeys']] = None,
        required: Optional[Iterable['types.LikeKeys']] = None,
        optional: Optional[Iterable['types.LikeKeys']] = None,
        relations: Optional[Mapping['types.LikeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LikeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Like_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Like_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Like_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Like_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Like_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Like_relational_fields:
                        raise errors.UnknownRelationalFieldError('Like', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Like / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Like',
            }
        )
        _created_partial_types.add(name)


class Comment(bases.BaseComment):
    """Represents a Comment record"""

    commentId: _int
    postId: _int
    userId: _int
    content: _str
    createdAt: datetime.datetime
    post: Optional['models.Post'] = None
    user: Optional['models.UserProfile'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CommentKeys']] = None,
        exclude: Optional[Iterable['types.CommentKeys']] = None,
        required: Optional[Iterable['types.CommentKeys']] = None,
        optional: Optional[Iterable['types.CommentKeys']] = None,
        relations: Optional[Mapping['types.CommentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CommentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Comment_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Comment_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Comment_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Comment_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Comment_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Comment_relational_fields:
                        raise errors.UnknownRelationalFieldError('Comment', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Comment / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Comment',
            }
        )
        _created_partial_types.add(name)


class Skill(bases.BaseSkill):
    """Represents a Skill record"""

    skillId: _int
    userId: _int
    skillName: _str
    skillDescription: _str
    skillValue: _int
    yearExperience: _str
    user: Optional['models.UserProfile'] = None
    exchanges: Optional[List['models.ExchangeSkill']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SkillKeys']] = None,
        exclude: Optional[Iterable['types.SkillKeys']] = None,
        required: Optional[Iterable['types.SkillKeys']] = None,
        optional: Optional[Iterable['types.SkillKeys']] = None,
        relations: Optional[Mapping['types.SkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Skill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Skill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Skill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Skill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Skill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Skill_relational_fields:
                        raise errors.UnknownRelationalFieldError('Skill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Skill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Skill',
            }
        )
        _created_partial_types.add(name)


class TargetSkill(bases.BaseTargetSkill):
    """Represents a TargetSkill record"""

    targetSkillId: _int
    userId: _int
    skillName: _str
    user: Optional['models.UserProfile'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TargetSkillKeys']] = None,
        exclude: Optional[Iterable['types.TargetSkillKeys']] = None,
        required: Optional[Iterable['types.TargetSkillKeys']] = None,
        optional: Optional[Iterable['types.TargetSkillKeys']] = None,
        relations: Optional[Mapping['types.TargetSkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TargetSkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _TargetSkill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _TargetSkill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _TargetSkill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _TargetSkill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _TargetSkill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _TargetSkill_relational_fields:
                        raise errors.UnknownRelationalFieldError('TargetSkill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid TargetSkill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'TargetSkill',
            }
        )
        _created_partial_types.add(name)


class Conversation(bases.BaseConversation):
    """Represents a Conversation record"""

    id: _int
    messages: Optional[List['models.Message']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ConversationKeys']] = None,
        exclude: Optional[Iterable['types.ConversationKeys']] = None,
        required: Optional[Iterable['types.ConversationKeys']] = None,
        optional: Optional[Iterable['types.ConversationKeys']] = None,
        relations: Optional[Mapping['types.ConversationRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ConversationKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Conversation_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Conversation_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Conversation_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Conversation_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Conversation_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Conversation_relational_fields:
                        raise errors.UnknownRelationalFieldError('Conversation', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Conversation / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Conversation',
            }
        )
        _created_partial_types.add(name)


class Message(bases.BaseMessage):
    """Represents a Message record"""

    id: _int
    body: _str
    sentAt: datetime.datetime
    senderId: _int
    sender: Optional['models.UserProfile'] = None
    recipientId: _int
    recipient: Optional['models.UserProfile'] = None
    conversationId: _int
    conversation: Optional['models.Conversation'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MessageKeys']] = None,
        exclude: Optional[Iterable['types.MessageKeys']] = None,
        required: Optional[Iterable['types.MessageKeys']] = None,
        optional: Optional[Iterable['types.MessageKeys']] = None,
        relations: Optional[Mapping['types.MessageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MessageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Message_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Message_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Message_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Message_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Message_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Message_relational_fields:
                        raise errors.UnknownRelationalFieldError('Message', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Message / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Message',
            }
        )
        _created_partial_types.add(name)


class Exchange(bases.BaseExchange):
    """Represents a Exchange record"""

    exchangeId: _int
    userOneId: _int
    userTwoId: _int
    sender: Optional['models.UserProfile'] = None
    receiver: Optional['models.UserProfile'] = None
    status: 'enums.ExchangeStatus'
    createdAt: datetime.datetime
    exchangeSkills: Optional[List['models.ExchangeSkill']] = None
    reviews: Optional[List['models.Review']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ExchangeKeys']] = None,
        exclude: Optional[Iterable['types.ExchangeKeys']] = None,
        required: Optional[Iterable['types.ExchangeKeys']] = None,
        optional: Optional[Iterable['types.ExchangeKeys']] = None,
        relations: Optional[Mapping['types.ExchangeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ExchangeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Exchange_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Exchange_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Exchange_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Exchange_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Exchange_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Exchange_relational_fields:
                        raise errors.UnknownRelationalFieldError('Exchange', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Exchange / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Exchange',
            }
        )
        _created_partial_types.add(name)


class ExchangeSkill(bases.BaseExchangeSkill):
    """Represents a ExchangeSkill record"""

    id: _int
    exchangeId: _int
    skillId: _int
    exchange: Optional['models.Exchange'] = None
    skill: Optional['models.Skill'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ExchangeSkillKeys']] = None,
        exclude: Optional[Iterable['types.ExchangeSkillKeys']] = None,
        required: Optional[Iterable['types.ExchangeSkillKeys']] = None,
        optional: Optional[Iterable['types.ExchangeSkillKeys']] = None,
        relations: Optional[Mapping['types.ExchangeSkillRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ExchangeSkillKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ExchangeSkill_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ExchangeSkill_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ExchangeSkill_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ExchangeSkill_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ExchangeSkill_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ExchangeSkill_relational_fields:
                        raise errors.UnknownRelationalFieldError('ExchangeSkill', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ExchangeSkill / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ExchangeSkill',
            }
        )
        _created_partial_types.add(name)


class Review(bases.BaseReview):
    """Represents a Review record"""

    reviewId: _int
    exchangeId: _int
    reviewerId: _int
    revieweeId: _int
    rating: _int
    description: Optional[_str] = None
    createdAt: datetime.datetime
    exchange: Optional['models.Exchange'] = None
    reviewer: Optional['models.UserProfile'] = None
    reviewee: Optional['models.UserProfile'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReviewKeys']] = None,
        exclude: Optional[Iterable['types.ReviewKeys']] = None,
        required: Optional[Iterable['types.ReviewKeys']] = None,
        optional: Optional[Iterable['types.ReviewKeys']] = None,
        relations: Optional[Mapping['types.ReviewRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReviewKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Review_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Review_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Review_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Review_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Review_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Review_relational_fields:
                        raise errors.UnknownRelationalFieldError('Review', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Review / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Review',
            }
        )
        _created_partial_types.add(name)


class SearchHistory(bases.BaseSearchHistory):
    """Represents a SearchHistory record"""

    searchHistoryId: _int
    userId: _int
    searchQuery: _str
    searchedAt: datetime.datetime
    numTimesSearched: _int
    user: Optional['models.UserProfile'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.SearchHistoryKeys']] = None,
        exclude: Optional[Iterable['types.SearchHistoryKeys']] = None,
        required: Optional[Iterable['types.SearchHistoryKeys']] = None,
        optional: Optional[Iterable['types.SearchHistoryKeys']] = None,
        relations: Optional[Mapping['types.SearchHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.SearchHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _SearchHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _SearchHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _SearchHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _SearchHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _SearchHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _SearchHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('SearchHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid SearchHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'SearchHistory',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'profile',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('fName', {
            'name': 'fName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lName', {
            'name': 'lName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.Role',
            'is_relational': False,
            'documentation': None,
        }),
        ('profile', {
            'name': 'profile',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserProfile_relational_fields: Set[str] = {
        'user',
        'posts',
        'likes',
        'comments',
        'skills',
        'targetSkills',
        'sentMessages',
        'receivedMessages',
        'sentExchanges',
        'receivedExchanges',
        'reviewsGiven',
        'reviewsReceived',
        'searchHistories',
    }
_UserProfile_fields: Dict['types.UserProfileKeys', PartialModelField] = OrderedDict(
    [
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('profile_picture', {
            'name': 'profile_picture',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('general_location', {
            'name': 'general_location',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('posts', {
            'name': 'posts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Post\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('likes', {
            'name': 'likes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Like\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('comments', {
            'name': 'comments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Comment\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('skills', {
            'name': 'skills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Skill\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('targetSkills', {
            'name': 'targetSkills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.TargetSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sentMessages', {
            'name': 'sentMessages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('receivedMessages', {
            'name': 'receivedMessages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('sentExchanges', {
            'name': 'sentExchanges',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Exchange\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('receivedExchanges', {
            'name': 'receivedExchanges',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Exchange\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewsGiven', {
            'name': 'reviewsGiven',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewsReceived', {
            'name': 'reviewsReceived',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('searchHistories', {
            'name': 'searchHistories',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.SearchHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Post_relational_fields: Set[str] = {
        'user',
        'likes',
        'comments',
    }
_Post_fields: Dict['types.PostKeys', PartialModelField] = OrderedDict(
    [
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('img', {
            'name': 'img',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('likes', {
            'name': 'likes',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Like\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('comments', {
            'name': 'comments',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Comment\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Like_relational_fields: Set[str] = {
        'post',
        'user',
    }
_Like_fields: Dict['types.LikeKeys', PartialModelField] = OrderedDict(
    [
        ('likeId', {
            'name': 'likeId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': False,
            'optional': True,
            'type': 'models.Post',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Comment_relational_fields: Set[str] = {
        'post',
        'user',
    }
_Comment_fields: Dict['types.CommentKeys', PartialModelField] = OrderedDict(
    [
        ('commentId', {
            'name': 'commentId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('postId', {
            'name': 'postId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': False,
            'optional': True,
            'type': 'models.Post',
            'is_relational': True,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Skill_relational_fields: Set[str] = {
        'user',
        'exchanges',
    }
_Skill_fields: Dict['types.SkillKeys', PartialModelField] = OrderedDict(
    [
        ('skillId', {
            'name': 'skillId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillName', {
            'name': 'skillName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillDescription', {
            'name': 'skillDescription',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillValue', {
            'name': 'skillValue',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('yearExperience', {
            'name': 'yearExperience',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('exchanges', {
            'name': 'exchanges',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ExchangeSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_TargetSkill_relational_fields: Set[str] = {
        'user',
    }
_TargetSkill_fields: Dict['types.TargetSkillKeys', PartialModelField] = OrderedDict(
    [
        ('targetSkillId', {
            'name': 'targetSkillId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillName', {
            'name': 'skillName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Conversation_relational_fields: Set[str] = {
        'messages',
    }
_Conversation_fields: Dict['types.ConversationKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Message_relational_fields: Set[str] = {
        'sender',
        'recipient',
        'conversation',
    }
_Message_fields: Dict['types.MessageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('body', {
            'name': 'body',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentAt', {
            'name': 'sentAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('senderId', {
            'name': 'senderId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sender', {
            'name': 'sender',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('recipientId', {
            'name': 'recipientId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('recipient', {
            'name': 'recipient',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('conversationId', {
            'name': 'conversationId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('conversation', {
            'name': 'conversation',
            'is_list': False,
            'optional': True,
            'type': 'models.Conversation',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Exchange_relational_fields: Set[str] = {
        'sender',
        'receiver',
        'exchangeSkills',
        'reviews',
    }
_Exchange_fields: Dict['types.ExchangeKeys', PartialModelField] = OrderedDict(
    [
        ('exchangeId', {
            'name': 'exchangeId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userOneId', {
            'name': 'userOneId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userTwoId', {
            'name': 'userTwoId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sender', {
            'name': 'sender',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('receiver', {
            'name': 'receiver',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ExchangeStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('exchangeSkills', {
            'name': 'exchangeSkills',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ExchangeSkill\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviews', {
            'name': 'reviews',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ExchangeSkill_relational_fields: Set[str] = {
        'exchange',
        'skill',
    }
_ExchangeSkill_fields: Dict['types.ExchangeSkillKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('exchangeId', {
            'name': 'exchangeId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('skillId', {
            'name': 'skillId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('exchange', {
            'name': 'exchange',
            'is_list': False,
            'optional': True,
            'type': 'models.Exchange',
            'is_relational': True,
            'documentation': None,
        }),
        ('skill', {
            'name': 'skill',
            'is_list': False,
            'optional': True,
            'type': 'models.Skill',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Review_relational_fields: Set[str] = {
        'exchange',
        'reviewer',
        'reviewee',
    }
_Review_fields: Dict['types.ReviewKeys', PartialModelField] = OrderedDict(
    [
        ('reviewId', {
            'name': 'reviewId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('exchangeId', {
            'name': 'exchangeId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('reviewerId', {
            'name': 'reviewerId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('revieweeId', {
            'name': 'revieweeId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('exchange', {
            'name': 'exchange',
            'is_list': False,
            'optional': True,
            'type': 'models.Exchange',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewer', {
            'name': 'reviewer',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
        ('reviewee', {
            'name': 'reviewee',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_SearchHistory_relational_fields: Set[str] = {
        'user',
    }
_SearchHistory_fields: Dict['types.SearchHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('searchHistoryId', {
            'name': 'searchHistoryId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('searchQuery', {
            'name': 'searchQuery',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('searchedAt', {
            'name': 'searchedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('numTimesSearched', {
            'name': 'numTimesSearched',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.UserProfile',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(UserProfile)
model_rebuild(Post)
model_rebuild(Like)
model_rebuild(Comment)
model_rebuild(Skill)
model_rebuild(TargetSkill)
model_rebuild(Conversation)
model_rebuild(Message)
model_rebuild(Exchange)
model_rebuild(ExchangeSkill)
model_rebuild(Review)
model_rebuild(SearchHistory)

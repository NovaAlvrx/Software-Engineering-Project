# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE userId = $1',
            1103527590,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE fName = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'fName': 'ggciceaie',
                'lName': 'bbehjachib',
                'email': 'cadfabfehe',
                'password': 'dgiiaaijj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'fName': 'bfaiacjjfc',
                    'lName': 'eigcfgbif',
                    'email': 'bagcfbhiig',
                    'password': 'cghideieh',
                },
                {
                    # data to create a User record
                    'fName': 'biabhbdai',
                    'lName': 'idghgaicb',
                    'email': 'fjfddhigg',
                    'password': 'hjaecfifb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'userId': 2111915288,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'userId': 1149758321,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'userId': 1644289366,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the lName field
        users = await User.prisma().find_many(
            take=5,
            order={
                'lName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the email field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the password field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'password': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'userId': 1388290519,
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'userId': 1647418052,
            },
            data={
                'create': {
                    'userId': 1647418052,
                    'fName': 'biabhbdai',
                    'lName': 'idghgaicb',
                    'email': 'fjfddhigg',
                    'password': 'hjaecfifb',
                },
                'update': {
                    'fName': 'biabhbdai',
                    'lName': 'idghgaicb',
                    'email': 'fjfddhigg',
                    'password': 'hjaecfifb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'role': enums.Role.USER
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'fName': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by lName values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['lName'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserProfileActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserProfile]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserProfile.prisma().query_raw(
            'SELECT * FROM UserProfile WHERE userId = $1',
            1675546029,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserProfile
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserProfile.prisma().query_first(
            'SELECT * FROM UserProfile WHERE profile_picture = $1',
            'bhghchehcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserProfileCreateInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created UserProfile record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserProfile record from just the required fields
        userprofile = await UserProfile.prisma().create(
            data={
                # data to create a UserProfile record
                'userId': 326272115,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserProfile records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserProfile record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserProfile.prisma().create_many(
            data=[
                {
                    # data to create a UserProfile record
                    'userId': 1343201072,
                },
                {
                    # data to create a UserProfile record
                    'userId': 675780521,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The deleted UserProfile record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().delete(
            where={
                'userId': 744964398,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserProfile record.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique(
            where={
                'userId': 1969681615,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserProfile record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserProfile filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The found UserProfile record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().find_unique_or_raise(
            where={
                'userId': 1116175964,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserProfile records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N results
        where
            UserProfile filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserProfile]
            The list of all UserProfile records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserProfile records
        userprofiles = await UserProfile.prisma().find_many(take=10)

        # find the first 5 UserProfile records ordered by the general_location field
        userprofiles = await UserProfile.prisma().find_many(
            take=5,
            order={
                'general_location': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserProfile record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the userId field
        userprofile = await UserProfile.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
        include: Optional[types.UserProfileInclude] = None,
        order: Optional[Union[types.UserProfileOrderByInput, List[types.UserProfileOrderByInput]]] = None,
        distinct: Optional[List[types.UserProfileScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserProfile record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserProfile filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserProfile model
        order
            Order the returned UserProfile records by any field
        distinct
            Filter UserProfile records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserProfile
            The first UserProfile record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserProfile record ordered by the profile_picture field
        userprofile = await UserProfile.prisma().find_first_or_raise(
            skip=1,
            order={
                'profile_picture': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserProfileUpdateInput,
        where: types.UserProfileWhereUniqueInput,
        include: Optional[types.UserProfileInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserProfile record.

        Parameters
        ----------
        data
            UserProfile record data specifying what to update
        where
            UserProfile filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The updated UserProfile record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().update(
            where={
                'userId': 861472101,
            },
            data={
                # data to update the UserProfile record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserProfileWhereUniqueInput,
        data: types.UserProfileUpsertInput,
        include: Optional[types.UserProfileInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserProfile filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserProfile model

        Returns
        -------
        prisma.models.UserProfile
            The created or updated UserProfile record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        userprofile = await UserProfile.prisma().upsert(
            where={
                'userId': 1303003706,
            },
            data={
                'create': {
                    'userId': 1303003706,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserProfileUpdateManyMutationInput,
        where: types.UserProfileWhereInput,
    ) -> int:
        """Update multiple UserProfile records

        Parameters
        ----------
        data
            UserProfile data to update the selected UserProfile records to
        where
            Filter to select the UserProfile records to update

        Returns
        -------
        int
            The total number of UserProfile records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserProfile records
        total = await UserProfile.prisma().update_many(
            data={
                'general_location': 'bgiggdidbf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserProfileCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> types.UserProfileCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserProfileCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserProfileWhereInput] = None,
        cursor: Optional[types.UserProfileWhereUniqueInput] = None,
    ) -> Union[int, types.UserProfileCountAggregateOutput]:
        """Count the number of UserProfile records present in the database

        Parameters
        ----------
        select
            Select the UserProfile fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserProfile filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserProfileCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserProfile.prisma().count()

        # results: prisma.types.UserProfileCountAggregateOutput
        results = await UserProfile.prisma().count(
            select={
                '_all': True,
                'profile_picture': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserProfileCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserProfileWhereInput] = None
    ) -> int:
        """Delete multiple UserProfile records.

        Parameters
        ----------
        where
            Optional UserProfile filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserProfile records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserProfile records
        total = await UserProfile.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserProfileScalarFieldKeys'],
        *,
        where: Optional['types.UserProfileWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserProfileAvgAggregateInput'] = None,
        sum: Optional['types.UserProfileSumAggregateInput'] = None,
        min: Optional['types.UserProfileMinAggregateInput'] = None,
        max: Optional['types.UserProfileMaxAggregateInput'] = None,
        having: Optional['types.UserProfileScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserProfileCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserProfileScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserProfileGroupByOutput']:
        """Group UserProfile records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserProfile fields to group records by
        where
            UserProfile filter to select records
        take
            Limit the maximum number of UserProfile records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserProfileGroupByOutput]
            A list of dictionaries representing the UserProfile record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserProfile records by general_location values
        # and count how many records are in each group
        results = await UserProfile.prisma().group_by(
            ['general_location'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PostActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Post]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Post.prisma().query_raw(
            'SELECT * FROM Post WHERE postId = $1',
            2000430152,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Post
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Post.prisma().query_first(
            'SELECT * FROM Post WHERE userId = $1',
            1868141281,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PostCreateInput,
        include: Optional[types.PostInclude] = None
    ) -> _PrismaModelT:
        """Create a new Post record.

        Parameters
        ----------
        data
            Post record data
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The created Post record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Post record from just the required fields
        post = await Post.prisma().create(
            data={
                # data to create a Post record
                'userId': 1860847622,
                'description': 'beeifcbebf',
                'img': 'bgcigfahea',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PostCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Post records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Post record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Post.prisma().create_many(
            data=[
                {
                    # data to create a Post record
                    'userId': 1249606685,
                    'description': 'idfjadbcc',
                    'img': 'hgdhbjhhj',
                },
                {
                    # data to create a Post record
                    'userId': 429995104,
                    'description': 'bhhfibbigf',
                    'img': 'ijdbeffgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Post record.

        Parameters
        ----------
        where
            Post filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The deleted Post record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().delete(
            where={
                'postId': 995405759,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Post record.

        Parameters
        ----------
        where
            Post filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The found Post record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().find_unique(
            where={
                'postId': 2102736524,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Post record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Post filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The found Post record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().find_unique_or_raise(
            where={
                'postId': 271520213,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
        distinct: Optional[List[types.PostScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Post records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Post records returned
        skip
            Ignore the first N results
        where
            Post filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Post model
        order
            Order the returned Post records by any field
        distinct
            Filter Post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Post]
            The list of all Post records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Post records
        posts = await Post.prisma().find_many(take=10)

        # find the first 5 Post records ordered by the description field
        posts = await Post.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
        distinct: Optional[List[types.PostScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Post record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Post filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Post model
        order
            Order the returned Post records by any field
        distinct
            Filter Post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Post
            The first Post record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Post record ordered by the img field
        post = await Post.prisma().find_first(
            skip=1,
            order={
                'img': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
        distinct: Optional[List[types.PostScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Post record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Post filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Post model
        order
            Order the returned Post records by any field
        distinct
            Filter Post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Post
            The first Post record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Post record ordered by the createdAt field
        post = await Post.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PostUpdateInput,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Post record.

        Parameters
        ----------
        data
            Post record data specifying what to update
        where
            Post filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The updated Post record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        post = await Post.prisma().update(
            where={
                'postId': 456633834,
            },
            data={
                # data to update the Post record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PostWhereUniqueInput,
        data: types.PostUpsertInput,
        include: Optional[types.PostInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Post filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Post model

        Returns
        -------
        prisma.models.Post
            The created or updated Post record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = await Post.prisma().upsert(
            where={
                'postId': 2058258651,
            },
            data={
                'create': {
                    'postId': 2058258651,
                    'userId': 429995104,
                    'description': 'bhhfibbigf',
                    'img': 'ijdbeffgg',
                },
                'update': {
                    'userId': 429995104,
                    'description': 'bhhfibbigf',
                    'img': 'ijdbeffgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PostUpdateManyMutationInput,
        where: types.PostWhereInput,
    ) -> int:
        """Update multiple Post records

        Parameters
        ----------
        data
            Post data to update the selected Post records to
        where
            Filter to select the Post records to update

        Returns
        -------
        int
            The total number of Post records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Post records
        total = await Post.prisma().update_many(
            data={
                'postId': 1583689592
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Post records present in the database

        Parameters
        ----------
        select
            Select the Post fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Post filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Post.prisma().count()

        # results: prisma.types.PostCountAggregateOutput
        results = await Post.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PostCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
    ) -> types.PostCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PostCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
    ) -> Union[int, types.PostCountAggregateOutput]:
        """Count the number of Post records present in the database

        Parameters
        ----------
        select
            Select the Post fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Post filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Post.prisma().count()

        # results: prisma.types.PostCountAggregateOutput
        results = await Post.prisma().count(
            select={
                '_all': True,
                'description': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PostCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PostWhereInput] = None
    ) -> int:
        """Delete multiple Post records.

        Parameters
        ----------
        where
            Optional Post filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Post records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Post records
        total = await Post.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PostScalarFieldKeys'],
        *,
        where: Optional['types.PostWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PostAvgAggregateInput'] = None,
        sum: Optional['types.PostSumAggregateInput'] = None,
        min: Optional['types.PostMinAggregateInput'] = None,
        max: Optional['types.PostMaxAggregateInput'] = None,
        having: Optional['types.PostScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PostCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PostScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PostScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PostGroupByOutput']:
        """Group Post records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Post fields to group records by
        where
            Post filter to select records
        take
            Limit the maximum number of Post records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PostGroupByOutput]
            A list of dictionaries representing the Post record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Post records by img values
        # and count how many records are in each group
        results = await Post.prisma().group_by(
            ['img'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LikeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Like]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Like.prisma().query_raw(
            'SELECT * FROM Like WHERE likeId = $1',
            878442065,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Like
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Like.prisma().query_first(
            'SELECT * FROM Like WHERE postId = $1',
            1675280054,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LikeCreateInput,
        include: Optional[types.LikeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Like record.

        Parameters
        ----------
        data
            Like record data
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The created Like record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Like record from just the required fields
        like = await Like.prisma().create(
            data={
                # data to create a Like record
                'postId': 1627576247,
                'userId': 2054802212,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LikeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Like records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Like record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Like.prisma().create_many(
            data=[
                {
                    # data to create a Like record
                    'postId': 60335757,
                    'userId': 684462146,
                },
                {
                    # data to create a Like record
                    'postId': 1625503827,
                    'userId': 521827728,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Like record.

        Parameters
        ----------
        where
            Like filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The deleted Like record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().delete(
            where={
                'likeId': 1266032265,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Like record.

        Parameters
        ----------
        where
            Like filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The found Like record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().find_unique(
            where={
                'likeId': 93253262,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Like record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Like filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The found Like record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().find_unique_or_raise(
            where={
                'likeId': 2053047983,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Like records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Like records returned
        skip
            Ignore the first N results
        where
            Like filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Like]
            The list of all Like records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Like records
        likes = await Like.prisma().find_many(take=10)

        # find the first 5 Like records ordered by the userId field
        likes = await Like.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Like record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Like filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Like
            The first Like record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Like record ordered by the likeId field
        like = await Like.prisma().find_first(
            skip=1,
            order={
                'likeId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
        include: Optional[types.LikeInclude] = None,
        order: Optional[Union[types.LikeOrderByInput, List[types.LikeOrderByInput]]] = None,
        distinct: Optional[List[types.LikeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Like record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Like filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Like model
        order
            Order the returned Like records by any field
        distinct
            Filter Like records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Like
            The first Like record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Like record ordered by the postId field
        like = await Like.prisma().find_first_or_raise(
            skip=1,
            order={
                'postId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LikeUpdateInput,
        where: types.LikeWhereUniqueInput,
        include: Optional[types.LikeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Like record.

        Parameters
        ----------
        data
            Like record data specifying what to update
        where
            Like filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The updated Like record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        like = await Like.prisma().update(
            where={
                'likeId': 685333180,
            },
            data={
                # data to update the Like record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LikeWhereUniqueInput,
        data: types.LikeUpsertInput,
        include: Optional[types.LikeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Like filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Like model

        Returns
        -------
        prisma.models.Like
            The created or updated Like record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        like = await Like.prisma().upsert(
            where={
                'likeId': 127474245,
            },
            data={
                'create': {
                    'likeId': 127474245,
                    'postId': 1625503827,
                    'userId': 521827728,
                },
                'update': {
                    'postId': 1625503827,
                    'userId': 521827728,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LikeUpdateManyMutationInput,
        where: types.LikeWhereInput,
    ) -> int:
        """Update multiple Like records

        Parameters
        ----------
        data
            Like data to update the selected Like records to
        where
            Filter to select the Like records to update

        Returns
        -------
        int
            The total number of Like records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Like records
        total = await Like.prisma().update_many(
            data={
                'userId': 948921754
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Like records present in the database

        Parameters
        ----------
        select
            Select the Like fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Like filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LikeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Like.prisma().count()

        # results: prisma.types.LikeCountAggregateOutput
        results = await Like.prisma().count(
            select={
                '_all': True,
                'likeId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LikeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> types.LikeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LikeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LikeWhereInput] = None,
        cursor: Optional[types.LikeWhereUniqueInput] = None,
    ) -> Union[int, types.LikeCountAggregateOutput]:
        """Count the number of Like records present in the database

        Parameters
        ----------
        select
            Select the Like fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Like filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LikeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Like.prisma().count()

        # results: prisma.types.LikeCountAggregateOutput
        results = await Like.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LikeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LikeWhereInput] = None
    ) -> int:
        """Delete multiple Like records.

        Parameters
        ----------
        where
            Optional Like filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Like records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Like records
        total = await Like.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LikeScalarFieldKeys'],
        *,
        where: Optional['types.LikeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LikeAvgAggregateInput'] = None,
        sum: Optional['types.LikeSumAggregateInput'] = None,
        min: Optional['types.LikeMinAggregateInput'] = None,
        max: Optional['types.LikeMaxAggregateInput'] = None,
        having: Optional['types.LikeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LikeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LikeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LikeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LikeGroupByOutput']:
        """Group Like records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Like fields to group records by
        where
            Like filter to select records
        take
            Limit the maximum number of Like records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LikeGroupByOutput]
            A list of dictionaries representing the Like record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Like records by userId values
        # and count how many records are in each group
        results = await Like.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CommentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Comment]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Comment.prisma().query_raw(
            'SELECT * FROM Comment WHERE commentId = $1',
            1964990155,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Comment
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Comment.prisma().query_first(
            'SELECT * FROM Comment WHERE postId = $1',
            1228891816,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CommentCreateInput,
        include: Optional[types.CommentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Comment record.

        Parameters
        ----------
        data
            Comment record data
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The created Comment record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Comment record from just the required fields
        comment = await Comment.prisma().create(
            data={
                # data to create a Comment record
                'postId': 255202753,
                'userId': 1223573862,
                'content': 'febcgjbfj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CommentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Comment records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Comment record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Comment.prisma().create_many(
            data=[
                {
                    # data to create a Comment record
                    'postId': 1064846676,
                    'userId': 508382461,
                    'content': 'bacecgfhbe',
                },
                {
                    # data to create a Comment record
                    'postId': 872078403,
                    'userId': 1874748096,
                    'content': 'jbgijghgb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Comment record.

        Parameters
        ----------
        where
            Comment filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The deleted Comment record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().delete(
            where={
                'commentId': 769267518,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Comment record.

        Parameters
        ----------
        where
            Comment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The found Comment record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().find_unique(
            where={
                'commentId': 820312479,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Comment record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Comment filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The found Comment record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().find_unique_or_raise(
            where={
                'commentId': 92728044,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Comment records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Comment records returned
        skip
            Ignore the first N results
        where
            Comment filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Comment]
            The list of all Comment records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Comment records
        comments = await Comment.prisma().find_many(take=10)

        # find the first 5 Comment records ordered by the userId field
        comments = await Comment.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Comment record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Comment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Comment
            The first Comment record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Comment record ordered by the content field
        comment = await Comment.prisma().find_first(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
        include: Optional[types.CommentInclude] = None,
        order: Optional[Union[types.CommentOrderByInput, List[types.CommentOrderByInput]]] = None,
        distinct: Optional[List[types.CommentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Comment record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Comment filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Comment model
        order
            Order the returned Comment records by any field
        distinct
            Filter Comment records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Comment
            The first Comment record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Comment record ordered by the createdAt field
        comment = await Comment.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CommentUpdateInput,
        where: types.CommentWhereUniqueInput,
        include: Optional[types.CommentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Comment record.

        Parameters
        ----------
        data
            Comment record data specifying what to update
        where
            Comment filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The updated Comment record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        comment = await Comment.prisma().update(
            where={
                'commentId': 344858293,
            },
            data={
                # data to update the Comment record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CommentWhereUniqueInput,
        data: types.CommentUpsertInput,
        include: Optional[types.CommentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Comment filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Comment model

        Returns
        -------
        prisma.models.Comment
            The created or updated Comment record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        comment = await Comment.prisma().upsert(
            where={
                'commentId': 1121741130,
            },
            data={
                'create': {
                    'commentId': 1121741130,
                    'postId': 872078403,
                    'userId': 1874748096,
                    'content': 'jbgijghgb',
                },
                'update': {
                    'postId': 872078403,
                    'userId': 1874748096,
                    'content': 'jbgijghgb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CommentUpdateManyMutationInput,
        where: types.CommentWhereInput,
    ) -> int:
        """Update multiple Comment records

        Parameters
        ----------
        data
            Comment data to update the selected Comment records to
        where
            Filter to select the Comment records to update

        Returns
        -------
        int
            The total number of Comment records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Comment records
        total = await Comment.prisma().update_many(
            data={
                'commentId': 1495896251
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Comment records present in the database

        Parameters
        ----------
        select
            Select the Comment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Comment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Comment.prisma().count()

        # results: prisma.types.CommentCountAggregateOutput
        results = await Comment.prisma().count(
            select={
                '_all': True,
                'postId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CommentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> types.CommentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CommentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CommentWhereInput] = None,
        cursor: Optional[types.CommentWhereUniqueInput] = None,
    ) -> Union[int, types.CommentCountAggregateOutput]:
        """Count the number of Comment records present in the database

        Parameters
        ----------
        select
            Select the Comment fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Comment filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CommentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Comment.prisma().count()

        # results: prisma.types.CommentCountAggregateOutput
        results = await Comment.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CommentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CommentWhereInput] = None
    ) -> int:
        """Delete multiple Comment records.

        Parameters
        ----------
        where
            Optional Comment filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Comment records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Comment records
        total = await Comment.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CommentScalarFieldKeys'],
        *,
        where: Optional['types.CommentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CommentAvgAggregateInput'] = None,
        sum: Optional['types.CommentSumAggregateInput'] = None,
        min: Optional['types.CommentMinAggregateInput'] = None,
        max: Optional['types.CommentMaxAggregateInput'] = None,
        having: Optional['types.CommentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CommentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CommentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CommentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CommentGroupByOutput']:
        """Group Comment records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Comment fields to group records by
        where
            Comment filter to select records
        take
            Limit the maximum number of Comment records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CommentGroupByOutput]
            A list of dictionaries representing the Comment record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Comment records by content values
        # and count how many records are in each group
        results = await Comment.prisma().group_by(
            ['content'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Skill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Skill.prisma().query_raw(
            'SELECT * FROM Skill WHERE skillId = $1',
            208521688,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Skill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Skill.prisma().query_first(
            'SELECT * FROM Skill WHERE userId = $1',
            860811569,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SkillCreateInput,
        include: Optional[types.SkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new Skill record.

        Parameters
        ----------
        data
            Skill record data
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The created Skill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Skill record from just the required fields
        skill = await Skill.prisma().create(
            data={
                # data to create a Skill record
                'userId': 1660932118,
                'skillName': 'fcfhgbjed',
                'skillDescription': 'hdgcajhjg',
                'skillValue': 493907821,
                'yearExperience': 'gdjgigfgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Skill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Skill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Skill.prisma().create_many(
            data=[
                {
                    # data to create a Skill record
                    'userId': 654007347,
                    'skillName': 'bjafcgbffc',
                    'skillDescription': 'hihegjif',
                    'skillValue': 1398328302,
                    'yearExperience': 'ifgaaagff',
                },
                {
                    # data to create a Skill record
                    'userId': 1452336924,
                    'skillName': 'bfhdbjjgfd',
                    'skillDescription': 'cabdjadaji',
                    'skillValue': 500965035,
                    'yearExperience': 'biaagcedjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Skill record.

        Parameters
        ----------
        where
            Skill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The deleted Skill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().delete(
            where={
                'skillId': 2077067425,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Skill record.

        Parameters
        ----------
        where
            Skill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The found Skill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().find_unique(
            where={
                'skillId': 1672112838,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Skill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Skill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The found Skill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().find_unique_or_raise(
            where={
                'skillId': 926677639,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
        include: Optional[types.SkillInclude] = None,
        order: Optional[Union[types.SkillOrderByInput, List[types.SkillOrderByInput]]] = None,
        distinct: Optional[List[types.SkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Skill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Skill records returned
        skip
            Ignore the first N results
        where
            Skill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Skill model
        order
            Order the returned Skill records by any field
        distinct
            Filter Skill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Skill]
            The list of all Skill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Skill records
        skills = await Skill.prisma().find_many(take=10)

        # find the first 5 Skill records ordered by the skillName field
        skills = await Skill.prisma().find_many(
            take=5,
            order={
                'skillName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
        include: Optional[types.SkillInclude] = None,
        order: Optional[Union[types.SkillOrderByInput, List[types.SkillOrderByInput]]] = None,
        distinct: Optional[List[types.SkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Skill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Skill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Skill model
        order
            Order the returned Skill records by any field
        distinct
            Filter Skill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Skill
            The first Skill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Skill record ordered by the skillDescription field
        skill = await Skill.prisma().find_first(
            skip=1,
            order={
                'skillDescription': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
        include: Optional[types.SkillInclude] = None,
        order: Optional[Union[types.SkillOrderByInput, List[types.SkillOrderByInput]]] = None,
        distinct: Optional[List[types.SkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Skill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Skill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Skill model
        order
            Order the returned Skill records by any field
        distinct
            Filter Skill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Skill
            The first Skill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Skill record ordered by the skillValue field
        skill = await Skill.prisma().find_first_or_raise(
            skip=1,
            order={
                'skillValue': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SkillUpdateInput,
        where: types.SkillWhereUniqueInput,
        include: Optional[types.SkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Skill record.

        Parameters
        ----------
        data
            Skill record data specifying what to update
        where
            Skill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The updated Skill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        skill = await Skill.prisma().update(
            where={
                'skillId': 1447624116,
            },
            data={
                # data to update the Skill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SkillWhereUniqueInput,
        data: types.SkillUpsertInput,
        include: Optional[types.SkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Skill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Skill model

        Returns
        -------
        prisma.models.Skill
            The created or updated Skill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        skill = await Skill.prisma().upsert(
            where={
                'skillId': 1738083805,
            },
            data={
                'create': {
                    'skillId': 1738083805,
                    'userId': 1452336924,
                    'skillName': 'bfhdbjjgfd',
                    'skillDescription': 'cabdjadaji',
                    'skillValue': 500965035,
                    'yearExperience': 'biaagcedjc',
                },
                'update': {
                    'userId': 1452336924,
                    'skillName': 'bfhdbjjgfd',
                    'skillDescription': 'cabdjadaji',
                    'skillValue': 500965035,
                    'yearExperience': 'biaagcedjc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SkillUpdateManyMutationInput,
        where: types.SkillWhereInput,
    ) -> int:
        """Update multiple Skill records

        Parameters
        ----------
        data
            Skill data to update the selected Skill records to
        where
            Filter to select the Skill records to update

        Returns
        -------
        int
            The total number of Skill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Skill records
        total = await Skill.prisma().update_many(
            data={
                'yearExperience': 'deajegcfi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Skill records present in the database

        Parameters
        ----------
        select
            Select the Skill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Skill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Skill.prisma().count()

        # results: prisma.types.SkillCountAggregateOutput
        results = await Skill.prisma().count(
            select={
                '_all': True,
                'skillId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
    ) -> types.SkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SkillWhereInput] = None,
        cursor: Optional[types.SkillWhereUniqueInput] = None,
    ) -> Union[int, types.SkillCountAggregateOutput]:
        """Count the number of Skill records present in the database

        Parameters
        ----------
        select
            Select the Skill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Skill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Skill.prisma().count()

        # results: prisma.types.SkillCountAggregateOutput
        results = await Skill.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SkillWhereInput] = None
    ) -> int:
        """Delete multiple Skill records.

        Parameters
        ----------
        where
            Optional Skill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Skill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Skill records
        total = await Skill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SkillScalarFieldKeys'],
        *,
        where: Optional['types.SkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SkillAvgAggregateInput'] = None,
        sum: Optional['types.SkillSumAggregateInput'] = None,
        min: Optional['types.SkillMinAggregateInput'] = None,
        max: Optional['types.SkillMaxAggregateInput'] = None,
        having: Optional['types.SkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SkillScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SkillScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SkillGroupByOutput']:
        """Group Skill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Skill fields to group records by
        where
            Skill filter to select records
        take
            Limit the maximum number of Skill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SkillGroupByOutput]
            A list of dictionaries representing the Skill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Skill records by skillName values
        # and count how many records are in each group
        results = await Skill.prisma().group_by(
            ['skillName'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TargetSkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.TargetSkill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await TargetSkill.prisma().query_raw(
            'SELECT * FROM TargetSkill WHERE targetSkillId = $1',
            601077795,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.TargetSkill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await TargetSkill.prisma().query_first(
            'SELECT * FROM TargetSkill WHERE userId = $1',
            290603296,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TargetSkillCreateInput,
        include: Optional[types.TargetSkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new TargetSkill record.

        Parameters
        ----------
        data
            TargetSkill record data
        include
            Specifies which relations should be loaded on the returned TargetSkill model

        Returns
        -------
        prisma.models.TargetSkill
            The created TargetSkill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a TargetSkill record from just the required fields
        targetskill = await TargetSkill.prisma().create(
            data={
                # data to create a TargetSkill record
                'userId': 1855826649,
                'skillName': 'bgbbaajbic',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TargetSkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple TargetSkill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of TargetSkill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await TargetSkill.prisma().create_many(
            data=[
                {
                    # data to create a TargetSkill record
                    'userId': 446673791,
                    'skillName': 'daafgidjg',
                },
                {
                    # data to create a TargetSkill record
                    'userId': 632626069,
                    'skillName': 'bhceabbgja',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TargetSkillWhereUniqueInput,
        include: Optional[types.TargetSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single TargetSkill record.

        Parameters
        ----------
        where
            TargetSkill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned TargetSkill model

        Returns
        -------
        prisma.models.TargetSkill
            The deleted TargetSkill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        targetskill = await TargetSkill.prisma().delete(
            where={
                'targetSkillId': 470157467,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TargetSkillWhereUniqueInput,
        include: Optional[types.TargetSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique TargetSkill record.

        Parameters
        ----------
        where
            TargetSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TargetSkill model

        Returns
        -------
        prisma.models.TargetSkill
            The found TargetSkill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        targetskill = await TargetSkill.prisma().find_unique(
            where={
                'targetSkillId': 1209209912,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TargetSkillWhereUniqueInput,
        include: Optional[types.TargetSkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique TargetSkill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            TargetSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned TargetSkill model

        Returns
        -------
        prisma.models.TargetSkill
            The found TargetSkill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        targetskill = await TargetSkill.prisma().find_unique_or_raise(
            where={
                'targetSkillId': 1536744465,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TargetSkillWhereInput] = None,
        cursor: Optional[types.TargetSkillWhereUniqueInput] = None,
        include: Optional[types.TargetSkillInclude] = None,
        order: Optional[Union[types.TargetSkillOrderByInput, List[types.TargetSkillOrderByInput]]] = None,
        distinct: Optional[List[types.TargetSkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple TargetSkill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of TargetSkill records returned
        skip
            Ignore the first N results
        where
            TargetSkill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TargetSkill model
        order
            Order the returned TargetSkill records by any field
        distinct
            Filter TargetSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.TargetSkill]
            The list of all TargetSkill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 TargetSkill records
        targetskills = await TargetSkill.prisma().find_many(take=10)

        # find the first 5 TargetSkill records ordered by the skillName field
        targetskills = await TargetSkill.prisma().find_many(
            take=5,
            order={
                'skillName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TargetSkillWhereInput] = None,
        cursor: Optional[types.TargetSkillWhereUniqueInput] = None,
        include: Optional[types.TargetSkillInclude] = None,
        order: Optional[Union[types.TargetSkillOrderByInput, List[types.TargetSkillOrderByInput]]] = None,
        distinct: Optional[List[types.TargetSkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single TargetSkill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TargetSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TargetSkill model
        order
            Order the returned TargetSkill records by any field
        distinct
            Filter TargetSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TargetSkill
            The first TargetSkill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TargetSkill record ordered by the targetSkillId field
        targetskill = await TargetSkill.prisma().find_first(
            skip=1,
            order={
                'targetSkillId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TargetSkillWhereInput] = None,
        cursor: Optional[types.TargetSkillWhereUniqueInput] = None,
        include: Optional[types.TargetSkillInclude] = None,
        order: Optional[Union[types.TargetSkillOrderByInput, List[types.TargetSkillOrderByInput]]] = None,
        distinct: Optional[List[types.TargetSkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single TargetSkill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            TargetSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned TargetSkill model
        order
            Order the returned TargetSkill records by any field
        distinct
            Filter TargetSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.TargetSkill
            The first TargetSkill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second TargetSkill record ordered by the userId field
        targetskill = await TargetSkill.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TargetSkillUpdateInput,
        where: types.TargetSkillWhereUniqueInput,
        include: Optional[types.TargetSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single TargetSkill record.

        Parameters
        ----------
        data
            TargetSkill record data specifying what to update
        where
            TargetSkill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned TargetSkill model

        Returns
        -------
        prisma.models.TargetSkill
            The updated TargetSkill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        targetskill = await TargetSkill.prisma().update(
            where={
                'targetSkillId': 424218998,
            },
            data={
                # data to update the TargetSkill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TargetSkillWhereUniqueInput,
        data: types.TargetSkillUpsertInput,
        include: Optional[types.TargetSkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            TargetSkill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned TargetSkill model

        Returns
        -------
        prisma.models.TargetSkill
            The created or updated TargetSkill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        targetskill = await TargetSkill.prisma().upsert(
            where={
                'targetSkillId': 2125632375,
            },
            data={
                'create': {
                    'targetSkillId': 2125632375,
                    'userId': 632626069,
                    'skillName': 'bhceabbgja',
                },
                'update': {
                    'userId': 632626069,
                    'skillName': 'bhceabbgja',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TargetSkillUpdateManyMutationInput,
        where: types.TargetSkillWhereInput,
    ) -> int:
        """Update multiple TargetSkill records

        Parameters
        ----------
        data
            TargetSkill data to update the selected TargetSkill records to
        where
            Filter to select the TargetSkill records to update

        Returns
        -------
        int
            The total number of TargetSkill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all TargetSkill records
        total = await TargetSkill.prisma().update_many(
            data={
                'skillName': 'fdgjfbhia'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TargetSkillWhereInput] = None,
        cursor: Optional[types.TargetSkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of TargetSkill records present in the database

        Parameters
        ----------
        select
            Select the TargetSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TargetSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TargetSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TargetSkill.prisma().count()

        # results: prisma.types.TargetSkillCountAggregateOutput
        results = await TargetSkill.prisma().count(
            select={
                '_all': True,
                'targetSkillId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TargetSkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TargetSkillWhereInput] = None,
        cursor: Optional[types.TargetSkillWhereUniqueInput] = None,
    ) -> types.TargetSkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TargetSkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TargetSkillWhereInput] = None,
        cursor: Optional[types.TargetSkillWhereUniqueInput] = None,
    ) -> Union[int, types.TargetSkillCountAggregateOutput]:
        """Count the number of TargetSkill records present in the database

        Parameters
        ----------
        select
            Select the TargetSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            TargetSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TargetSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await TargetSkill.prisma().count()

        # results: prisma.types.TargetSkillCountAggregateOutput
        results = await TargetSkill.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TargetSkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TargetSkillWhereInput] = None
    ) -> int:
        """Delete multiple TargetSkill records.

        Parameters
        ----------
        where
            Optional TargetSkill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of TargetSkill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all TargetSkill records
        total = await TargetSkill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TargetSkillScalarFieldKeys'],
        *,
        where: Optional['types.TargetSkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TargetSkillAvgAggregateInput'] = None,
        sum: Optional['types.TargetSkillSumAggregateInput'] = None,
        min: Optional['types.TargetSkillMinAggregateInput'] = None,
        max: Optional['types.TargetSkillMaxAggregateInput'] = None,
        having: Optional['types.TargetSkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TargetSkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TargetSkillScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TargetSkillScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TargetSkillGroupByOutput']:
        """Group TargetSkill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar TargetSkill fields to group records by
        where
            TargetSkill filter to select records
        take
            Limit the maximum number of TargetSkill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TargetSkillGroupByOutput]
            A list of dictionaries representing the TargetSkill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group TargetSkill records by skillName values
        # and count how many records are in each group
        results = await TargetSkill.prisma().group_by(
            ['skillName'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ConversationActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Conversation]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Conversation.prisma().query_raw(
            'SELECT * FROM Conversation WHERE id = $1',
            924723277,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Conversation
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Conversation.prisma().query_first(
            'SELECT * FROM Conversation WHERE id = $1',
            1621937922,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ConversationCreateInput,
        include: Optional[types.ConversationInclude] = None
    ) -> _PrismaModelT:
        """Create a new Conversation record.

        Parameters
        ----------
        data
            Conversation record data
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The created Conversation record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Conversation record from just the required fields
        conversation = await Conversation.prisma().create(
            data={
                # data to create a Conversation record
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ConversationCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Conversation records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Conversation record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Conversation.prisma().create_many(
            data=[
                {
                    # data to create a Conversation record
                },
                {
                    # data to create a Conversation record
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Conversation record.

        Parameters
        ----------
        where
            Conversation filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The deleted Conversation record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().delete(
            where={
                'id': 1848832019,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Conversation record.

        Parameters
        ----------
        where
            Conversation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The found Conversation record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().find_unique(
            where={
                'id': 1921528400,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Conversation record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Conversation filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The found Conversation record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().find_unique_or_raise(
            where={
                'id': 2100427849,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
        include: Optional[types.ConversationInclude] = None,
        order: Optional[Union[types.ConversationOrderByInput, List[types.ConversationOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Conversation records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Conversation records returned
        skip
            Ignore the first N results
        where
            Conversation filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conversation model
        order
            Order the returned Conversation records by any field
        distinct
            Filter Conversation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Conversation]
            The list of all Conversation records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Conversation records
        conversations = await Conversation.prisma().find_many(take=10)

        # find the first 5 Conversation records ordered by the id field
        conversations = await Conversation.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
        include: Optional[types.ConversationInclude] = None,
        order: Optional[Union[types.ConversationOrderByInput, List[types.ConversationOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Conversation record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Conversation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conversation model
        order
            Order the returned Conversation records by any field
        distinct
            Filter Conversation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Conversation
            The first Conversation record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Conversation record ordered by the id field
        conversation = await Conversation.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
        include: Optional[types.ConversationInclude] = None,
        order: Optional[Union[types.ConversationOrderByInput, List[types.ConversationOrderByInput]]] = None,
        distinct: Optional[List[types.ConversationScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Conversation record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Conversation filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Conversation model
        order
            Order the returned Conversation records by any field
        distinct
            Filter Conversation records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Conversation
            The first Conversation record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Conversation record ordered by the id field
        conversation = await Conversation.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ConversationUpdateInput,
        where: types.ConversationWhereUniqueInput,
        include: Optional[types.ConversationInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Conversation record.

        Parameters
        ----------
        data
            Conversation record data specifying what to update
        where
            Conversation filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The updated Conversation record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        conversation = await Conversation.prisma().update(
            where={
                'id': 849140046,
            },
            data={
                # data to update the Conversation record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ConversationWhereUniqueInput,
        data: types.ConversationUpsertInput,
        include: Optional[types.ConversationInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Conversation filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Conversation model

        Returns
        -------
        prisma.models.Conversation
            The created or updated Conversation record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        conversation = await Conversation.prisma().upsert(
            where={
                'id': 928152175,
            },
            data={
                'create': {
                    'id': 928152175,
                },
                'update': {
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ConversationUpdateManyMutationInput,
        where: types.ConversationWhereInput,
    ) -> int:
        """Update multiple Conversation records

        Parameters
        ----------
        data
            Conversation data to update the selected Conversation records to
        where
            Filter to select the Conversation records to update

        Returns
        -------
        int
            The total number of Conversation records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Conversation records
        total = await Conversation.prisma().update_many(
            data={
                'id': 273032060
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Conversation records present in the database

        Parameters
        ----------
        select
            Select the Conversation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Conversation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Conversation.prisma().count()

        # results: prisma.types.ConversationCountAggregateOutput
        results = await Conversation.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ConversationCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
    ) -> types.ConversationCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ConversationCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ConversationWhereInput] = None,
        cursor: Optional[types.ConversationWhereUniqueInput] = None,
    ) -> Union[int, types.ConversationCountAggregateOutput]:
        """Count the number of Conversation records present in the database

        Parameters
        ----------
        select
            Select the Conversation fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Conversation filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ConversationCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Conversation.prisma().count()

        # results: prisma.types.ConversationCountAggregateOutput
        results = await Conversation.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ConversationCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ConversationWhereInput] = None
    ) -> int:
        """Delete multiple Conversation records.

        Parameters
        ----------
        where
            Optional Conversation filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Conversation records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Conversation records
        total = await Conversation.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ConversationScalarFieldKeys'],
        *,
        where: Optional['types.ConversationWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ConversationAvgAggregateInput'] = None,
        sum: Optional['types.ConversationSumAggregateInput'] = None,
        min: Optional['types.ConversationMinAggregateInput'] = None,
        max: Optional['types.ConversationMaxAggregateInput'] = None,
        having: Optional['types.ConversationScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ConversationCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ConversationScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ConversationScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ConversationGroupByOutput']:
        """Group Conversation records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Conversation fields to group records by
        where
            Conversation filter to select records
        take
            Limit the maximum number of Conversation records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ConversationGroupByOutput]
            A list of dictionaries representing the Conversation record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Conversation records by id values
        # and count how many records are in each group
        results = await Conversation.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Message]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Message.prisma().query_raw(
            'SELECT * FROM Message WHERE id = $1',
            982848517,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Message
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Message.prisma().query_first(
            'SELECT * FROM Message WHERE body = $1',
            'fbahdheji',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'body': 'cbbheiicgh',
                'senderId': 1401944936,
                'recipientId': 1297607553,
                'conversationId': 519488550,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'body': 'jhgidcgbf',
                    'senderId': 1696425492,
                    'recipientId': 169262781,
                    'conversationId': 1023081650,
                },
                {
                    # data to create a Message record
                    'body': 'dchgibach',
                    'senderId': 527748992,
                    'recipientId': 2029357497,
                    'conversationId': 1318597118,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 2122112351,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 1024943020,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 1717307509,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the sentAt field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'sentAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the senderId field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'senderId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the recipientId field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'recipientId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 1598124042,
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 817623163,
            },
            data={
                'create': {
                    'id': 817623163,
                    'body': 'dchgibach',
                    'senderId': 527748992,
                    'recipientId': 2029357497,
                    'conversationId': 1318597118,
                },
                'update': {
                    'body': 'dchgibach',
                    'senderId': 527748992,
                    'recipientId': 2029357497,
                    'conversationId': 1318597118,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'conversationId': 1030557336
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'body': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeys'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by sentAt values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['sentAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ExchangeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Exchange]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Exchange.prisma().query_raw(
            'SELECT * FROM Exchange WHERE exchangeId = $1',
            1131525873,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Exchange
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Exchange.prisma().query_first(
            'SELECT * FROM Exchange WHERE userOneId = $1',
            210666198,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ExchangeCreateInput,
        include: Optional[types.ExchangeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Exchange record.

        Parameters
        ----------
        data
            Exchange record data
        include
            Specifies which relations should be loaded on the returned Exchange model

        Returns
        -------
        prisma.models.Exchange
            The created Exchange record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Exchange record from just the required fields
        exchange = await Exchange.prisma().create(
            data={
                # data to create a Exchange record
                'userOneId': 1276057943,
                'userTwoId': 745569348,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ExchangeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Exchange records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Exchange record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Exchange.prisma().create_many(
            data=[
                {
                    # data to create a Exchange record
                    'userOneId': 307876141,
                    'userTwoId': 1674049122,
                },
                {
                    # data to create a Exchange record
                    'userOneId': 1526854643,
                    'userTwoId': 958077104,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ExchangeWhereUniqueInput,
        include: Optional[types.ExchangeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Exchange record.

        Parameters
        ----------
        where
            Exchange filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Exchange model

        Returns
        -------
        prisma.models.Exchange
            The deleted Exchange record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchange = await Exchange.prisma().delete(
            where={
                'exchangeId': 1513050921,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ExchangeWhereUniqueInput,
        include: Optional[types.ExchangeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Exchange record.

        Parameters
        ----------
        where
            Exchange filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Exchange model

        Returns
        -------
        prisma.models.Exchange
            The found Exchange record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchange = await Exchange.prisma().find_unique(
            where={
                'exchangeId': 204674734,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ExchangeWhereUniqueInput,
        include: Optional[types.ExchangeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Exchange record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Exchange filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Exchange model

        Returns
        -------
        prisma.models.Exchange
            The found Exchange record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchange = await Exchange.prisma().find_unique_or_raise(
            where={
                'exchangeId': 2067651663,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeWhereInput] = None,
        cursor: Optional[types.ExchangeWhereUniqueInput] = None,
        include: Optional[types.ExchangeInclude] = None,
        order: Optional[Union[types.ExchangeOrderByInput, List[types.ExchangeOrderByInput]]] = None,
        distinct: Optional[List[types.ExchangeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Exchange records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Exchange records returned
        skip
            Ignore the first N results
        where
            Exchange filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Exchange model
        order
            Order the returned Exchange records by any field
        distinct
            Filter Exchange records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Exchange]
            The list of all Exchange records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Exchange records
        exchanges = await Exchange.prisma().find_many(take=10)

        # find the first 5 Exchange records ordered by the userTwoId field
        exchanges = await Exchange.prisma().find_many(
            take=5,
            order={
                'userTwoId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeWhereInput] = None,
        cursor: Optional[types.ExchangeWhereUniqueInput] = None,
        include: Optional[types.ExchangeInclude] = None,
        order: Optional[Union[types.ExchangeOrderByInput, List[types.ExchangeOrderByInput]]] = None,
        distinct: Optional[List[types.ExchangeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Exchange record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Exchange filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Exchange model
        order
            Order the returned Exchange records by any field
        distinct
            Filter Exchange records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Exchange
            The first Exchange record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Exchange record ordered by the offer field
        exchange = await Exchange.prisma().find_first(
            skip=1,
            order={
                'offer': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeWhereInput] = None,
        cursor: Optional[types.ExchangeWhereUniqueInput] = None,
        include: Optional[types.ExchangeInclude] = None,
        order: Optional[Union[types.ExchangeOrderByInput, List[types.ExchangeOrderByInput]]] = None,
        distinct: Optional[List[types.ExchangeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Exchange record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Exchange filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Exchange model
        order
            Order the returned Exchange records by any field
        distinct
            Filter Exchange records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Exchange
            The first Exchange record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Exchange record ordered by the request field
        exchange = await Exchange.prisma().find_first_or_raise(
            skip=1,
            order={
                'request': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ExchangeUpdateInput,
        where: types.ExchangeWhereUniqueInput,
        include: Optional[types.ExchangeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Exchange record.

        Parameters
        ----------
        data
            Exchange record data specifying what to update
        where
            Exchange filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Exchange model

        Returns
        -------
        prisma.models.Exchange
            The updated Exchange record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        exchange = await Exchange.prisma().update(
            where={
                'exchangeId': 1183911900,
            },
            data={
                # data to update the Exchange record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ExchangeWhereUniqueInput,
        data: types.ExchangeUpsertInput,
        include: Optional[types.ExchangeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Exchange filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Exchange model

        Returns
        -------
        prisma.models.Exchange
            The created or updated Exchange record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchange = await Exchange.prisma().upsert(
            where={
                'exchangeId': 1589704933,
            },
            data={
                'create': {
                    'exchangeId': 1589704933,
                    'userOneId': 1526854643,
                    'userTwoId': 958077104,
                },
                'update': {
                    'userOneId': 1526854643,
                    'userTwoId': 958077104,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ExchangeUpdateManyMutationInput,
        where: types.ExchangeWhereInput,
    ) -> int:
        """Update multiple Exchange records

        Parameters
        ----------
        data
            Exchange data to update the selected Exchange records to
        where
            Filter to select the Exchange records to update

        Returns
        -------
        int
            The total number of Exchange records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Exchange records
        total = await Exchange.prisma().update_many(
            data={
                'availability': 'bcedehfiji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeWhereInput] = None,
        cursor: Optional[types.ExchangeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Exchange records present in the database

        Parameters
        ----------
        select
            Select the Exchange fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Exchange filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ExchangeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Exchange.prisma().count()

        # results: prisma.types.ExchangeCountAggregateOutput
        results = await Exchange.prisma().count(
            select={
                '_all': True,
                'message': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ExchangeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeWhereInput] = None,
        cursor: Optional[types.ExchangeWhereUniqueInput] = None,
    ) -> types.ExchangeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ExchangeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeWhereInput] = None,
        cursor: Optional[types.ExchangeWhereUniqueInput] = None,
    ) -> Union[int, types.ExchangeCountAggregateOutput]:
        """Count the number of Exchange records present in the database

        Parameters
        ----------
        select
            Select the Exchange fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Exchange filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ExchangeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Exchange.prisma().count()

        # results: prisma.types.ExchangeCountAggregateOutput
        results = await Exchange.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ExchangeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ExchangeWhereInput] = None
    ) -> int:
        """Delete multiple Exchange records.

        Parameters
        ----------
        where
            Optional Exchange filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Exchange records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Exchange records
        total = await Exchange.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ExchangeScalarFieldKeys'],
        *,
        where: Optional['types.ExchangeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ExchangeAvgAggregateInput'] = None,
        sum: Optional['types.ExchangeSumAggregateInput'] = None,
        min: Optional['types.ExchangeMinAggregateInput'] = None,
        max: Optional['types.ExchangeMaxAggregateInput'] = None,
        having: Optional['types.ExchangeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ExchangeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ExchangeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ExchangeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ExchangeGroupByOutput']:
        """Group Exchange records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Exchange fields to group records by
        where
            Exchange filter to select records
        take
            Limit the maximum number of Exchange records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ExchangeGroupByOutput]
            A list of dictionaries representing the Exchange record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Exchange records by createdAt values
        # and count how many records are in each group
        results = await Exchange.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ExchangeSkillActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ExchangeSkill]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ExchangeSkill.prisma().query_raw(
            'SELECT * FROM ExchangeSkill WHERE id = $1',
            1369828971,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ExchangeSkill
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ExchangeSkill.prisma().query_first(
            'SELECT * FROM ExchangeSkill WHERE exchangeId = $1',
            1678593480,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ExchangeSkillCreateInput,
        include: Optional[types.ExchangeSkillInclude] = None
    ) -> _PrismaModelT:
        """Create a new ExchangeSkill record.

        Parameters
        ----------
        data
            ExchangeSkill record data
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model

        Returns
        -------
        prisma.models.ExchangeSkill
            The created ExchangeSkill record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ExchangeSkill record from just the required fields
        exchangeskill = await ExchangeSkill.prisma().create(
            data={
                # data to create a ExchangeSkill record
                'exchangeId': 403521121,
                'skillId': 648760710,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ExchangeSkillCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ExchangeSkill records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ExchangeSkill record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ExchangeSkill.prisma().create_many(
            data=[
                {
                    # data to create a ExchangeSkill record
                    'exchangeId': 607323719,
                    'skillId': 1468890740,
                },
                {
                    # data to create a ExchangeSkill record
                    'exchangeId': 629039005,
                    'skillId': 1214168082,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ExchangeSkillWhereUniqueInput,
        include: Optional[types.ExchangeSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ExchangeSkill record.

        Parameters
        ----------
        where
            ExchangeSkill filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model

        Returns
        -------
        prisma.models.ExchangeSkill
            The deleted ExchangeSkill record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchangeskill = await ExchangeSkill.prisma().delete(
            where={
                'id': 898613219,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ExchangeSkillWhereUniqueInput,
        include: Optional[types.ExchangeSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ExchangeSkill record.

        Parameters
        ----------
        where
            ExchangeSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model

        Returns
        -------
        prisma.models.ExchangeSkill
            The found ExchangeSkill record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchangeskill = await ExchangeSkill.prisma().find_unique(
            where={
                'id': 658378208,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ExchangeSkillWhereUniqueInput,
        include: Optional[types.ExchangeSkillInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ExchangeSkill record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ExchangeSkill filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model

        Returns
        -------
        prisma.models.ExchangeSkill
            The found ExchangeSkill record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchangeskill = await ExchangeSkill.prisma().find_unique_or_raise(
            where={
                'id': 954620057,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeSkillWhereInput] = None,
        cursor: Optional[types.ExchangeSkillWhereUniqueInput] = None,
        include: Optional[types.ExchangeSkillInclude] = None,
        order: Optional[Union[types.ExchangeSkillOrderByInput, List[types.ExchangeSkillOrderByInput]]] = None,
        distinct: Optional[List[types.ExchangeSkillScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ExchangeSkill records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ExchangeSkill records returned
        skip
            Ignore the first N results
        where
            ExchangeSkill filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model
        order
            Order the returned ExchangeSkill records by any field
        distinct
            Filter ExchangeSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ExchangeSkill]
            The list of all ExchangeSkill records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ExchangeSkill records
        exchangeskills = await ExchangeSkill.prisma().find_many(take=10)

        # find the first 5 ExchangeSkill records ordered by the skillId field
        exchangeskills = await ExchangeSkill.prisma().find_many(
            take=5,
            order={
                'skillId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeSkillWhereInput] = None,
        cursor: Optional[types.ExchangeSkillWhereUniqueInput] = None,
        include: Optional[types.ExchangeSkillInclude] = None,
        order: Optional[Union[types.ExchangeSkillOrderByInput, List[types.ExchangeSkillOrderByInput]]] = None,
        distinct: Optional[List[types.ExchangeSkillScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ExchangeSkill record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ExchangeSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model
        order
            Order the returned ExchangeSkill records by any field
        distinct
            Filter ExchangeSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ExchangeSkill
            The first ExchangeSkill record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ExchangeSkill record ordered by the id field
        exchangeskill = await ExchangeSkill.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeSkillWhereInput] = None,
        cursor: Optional[types.ExchangeSkillWhereUniqueInput] = None,
        include: Optional[types.ExchangeSkillInclude] = None,
        order: Optional[Union[types.ExchangeSkillOrderByInput, List[types.ExchangeSkillOrderByInput]]] = None,
        distinct: Optional[List[types.ExchangeSkillScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ExchangeSkill record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ExchangeSkill filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model
        order
            Order the returned ExchangeSkill records by any field
        distinct
            Filter ExchangeSkill records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ExchangeSkill
            The first ExchangeSkill record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ExchangeSkill record ordered by the exchangeId field
        exchangeskill = await ExchangeSkill.prisma().find_first_or_raise(
            skip=1,
            order={
                'exchangeId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ExchangeSkillUpdateInput,
        where: types.ExchangeSkillWhereUniqueInput,
        include: Optional[types.ExchangeSkillInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ExchangeSkill record.

        Parameters
        ----------
        data
            ExchangeSkill record data specifying what to update
        where
            ExchangeSkill filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model

        Returns
        -------
        prisma.models.ExchangeSkill
            The updated ExchangeSkill record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        exchangeskill = await ExchangeSkill.prisma().update(
            where={
                'id': 1214809950,
            },
            data={
                # data to update the ExchangeSkill record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ExchangeSkillWhereUniqueInput,
        data: types.ExchangeSkillUpsertInput,
        include: Optional[types.ExchangeSkillInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ExchangeSkill filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ExchangeSkill model

        Returns
        -------
        prisma.models.ExchangeSkill
            The created or updated ExchangeSkill record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        exchangeskill = await ExchangeSkill.prisma().upsert(
            where={
                'id': 1047820095,
            },
            data={
                'create': {
                    'id': 1047820095,
                    'exchangeId': 629039005,
                    'skillId': 1214168082,
                },
                'update': {
                    'exchangeId': 629039005,
                    'skillId': 1214168082,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ExchangeSkillUpdateManyMutationInput,
        where: types.ExchangeSkillWhereInput,
    ) -> int:
        """Update multiple ExchangeSkill records

        Parameters
        ----------
        data
            ExchangeSkill data to update the selected ExchangeSkill records to
        where
            Filter to select the ExchangeSkill records to update

        Returns
        -------
        int
            The total number of ExchangeSkill records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ExchangeSkill records
        total = await ExchangeSkill.prisma().update_many(
            data={
                'skillId': 1302734860
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeSkillWhereInput] = None,
        cursor: Optional[types.ExchangeSkillWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ExchangeSkill records present in the database

        Parameters
        ----------
        select
            Select the ExchangeSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ExchangeSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ExchangeSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ExchangeSkill.prisma().count()

        # results: prisma.types.ExchangeSkillCountAggregateOutput
        results = await ExchangeSkill.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ExchangeSkillCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeSkillWhereInput] = None,
        cursor: Optional[types.ExchangeSkillWhereUniqueInput] = None,
    ) -> types.ExchangeSkillCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ExchangeSkillCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ExchangeSkillWhereInput] = None,
        cursor: Optional[types.ExchangeSkillWhereUniqueInput] = None,
    ) -> Union[int, types.ExchangeSkillCountAggregateOutput]:
        """Count the number of ExchangeSkill records present in the database

        Parameters
        ----------
        select
            Select the ExchangeSkill fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ExchangeSkill filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ExchangeSkillCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ExchangeSkill.prisma().count()

        # results: prisma.types.ExchangeSkillCountAggregateOutput
        results = await ExchangeSkill.prisma().count(
            select={
                '_all': True,
                'exchangeId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ExchangeSkillCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ExchangeSkillWhereInput] = None
    ) -> int:
        """Delete multiple ExchangeSkill records.

        Parameters
        ----------
        where
            Optional ExchangeSkill filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ExchangeSkill records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ExchangeSkill records
        total = await ExchangeSkill.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ExchangeSkillScalarFieldKeys'],
        *,
        where: Optional['types.ExchangeSkillWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ExchangeSkillAvgAggregateInput'] = None,
        sum: Optional['types.ExchangeSkillSumAggregateInput'] = None,
        min: Optional['types.ExchangeSkillMinAggregateInput'] = None,
        max: Optional['types.ExchangeSkillMaxAggregateInput'] = None,
        having: Optional['types.ExchangeSkillScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ExchangeSkillCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ExchangeSkillScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ExchangeSkillScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ExchangeSkillGroupByOutput']:
        """Group ExchangeSkill records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ExchangeSkill fields to group records by
        where
            ExchangeSkill filter to select records
        take
            Limit the maximum number of ExchangeSkill records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ExchangeSkillGroupByOutput]
            A list of dictionaries representing the ExchangeSkill record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ExchangeSkill records by skillId values
        # and count how many records are in each group
        results = await ExchangeSkill.prisma().group_by(
            ['skillId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReviewActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Review]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Review.prisma().query_raw(
            'SELECT * FROM Review WHERE reviewId = $1',
            893052245,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Review
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Review.prisma().query_first(
            'SELECT * FROM Review WHERE exchangeId = $1',
            280083306,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReviewCreateInput,
        include: Optional[types.ReviewInclude] = None
    ) -> _PrismaModelT:
        """Create a new Review record.

        Parameters
        ----------
        data
            Review record data
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The created Review record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Review record from just the required fields
        review = await Review.prisma().create(
            data={
                # data to create a Review record
                'exchangeId': 549668955,
                'reviewerId': 76790008,
                'revieweeId': 2098299345,
                'rating': 245900342,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReviewCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Review records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Review record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Review.prisma().create_many(
            data=[
                {
                    # data to create a Review record
                    'exchangeId': 811863863,
                    'reviewerId': 1388801188,
                    'revieweeId': 752577037,
                    'rating': 1187663298,
                },
                {
                    # data to create a Review record
                    'exchangeId': 769681363,
                    'reviewerId': 1214295824,
                    'revieweeId': 1021417993,
                    'rating': 351503374,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Review record.

        Parameters
        ----------
        where
            Review filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The deleted Review record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().delete(
            where={
                'reviewId': 1321184815,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Review record.

        Parameters
        ----------
        where
            Review filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The found Review record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().find_unique(
            where={
                'reviewId': 369732668,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Review record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Review filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The found Review record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().find_unique_or_raise(
            where={
                'reviewId': 1191235013,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Review records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Review records returned
        skip
            Ignore the first N results
        where
            Review filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Review]
            The list of all Review records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Review records
        reviews = await Review.prisma().find_many(take=10)

        # find the first 5 Review records ordered by the reviewerId field
        reviews = await Review.prisma().find_many(
            take=5,
            order={
                'reviewerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Review record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Review filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Review
            The first Review record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Review record ordered by the revieweeId field
        review = await Review.prisma().find_first(
            skip=1,
            order={
                'revieweeId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Review record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Review filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Review
            The first Review record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Review record ordered by the rating field
        review = await Review.prisma().find_first_or_raise(
            skip=1,
            order={
                'rating': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReviewUpdateInput,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Review record.

        Parameters
        ----------
        data
            Review record data specifying what to update
        where
            Review filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The updated Review record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        review = await Review.prisma().update(
            where={
                'reviewId': 627561242,
            },
            data={
                # data to update the Review record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReviewWhereUniqueInput,
        data: types.ReviewUpsertInput,
        include: Optional[types.ReviewInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Review filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The created or updated Review record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().upsert(
            where={
                'reviewId': 1872952907,
            },
            data={
                'create': {
                    'reviewId': 1872952907,
                    'exchangeId': 769681363,
                    'reviewerId': 1214295824,
                    'revieweeId': 1021417993,
                    'rating': 351503374,
                },
                'update': {
                    'exchangeId': 769681363,
                    'reviewerId': 1214295824,
                    'revieweeId': 1021417993,
                    'rating': 351503374,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReviewUpdateManyMutationInput,
        where: types.ReviewWhereInput,
    ) -> int:
        """Update multiple Review records

        Parameters
        ----------
        data
            Review data to update the selected Review records to
        where
            Filter to select the Review records to update

        Returns
        -------
        int
            The total number of Review records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Review records
        total = await Review.prisma().update_many(
            data={
                'description': 'bhjdcicaii'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Review records present in the database

        Parameters
        ----------
        select
            Select the Review fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Review filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Review.prisma().count()

        # results: prisma.types.ReviewCountAggregateOutput
        results = await Review.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReviewCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> types.ReviewCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReviewCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> Union[int, types.ReviewCountAggregateOutput]:
        """Count the number of Review records present in the database

        Parameters
        ----------
        select
            Select the Review fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Review filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Review.prisma().count()

        # results: prisma.types.ReviewCountAggregateOutput
        results = await Review.prisma().count(
            select={
                '_all': True,
                'reviewId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReviewCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReviewWhereInput] = None
    ) -> int:
        """Delete multiple Review records.

        Parameters
        ----------
        where
            Optional Review filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Review records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Review records
        total = await Review.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReviewScalarFieldKeys'],
        *,
        where: Optional['types.ReviewWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReviewAvgAggregateInput'] = None,
        sum: Optional['types.ReviewSumAggregateInput'] = None,
        min: Optional['types.ReviewMinAggregateInput'] = None,
        max: Optional['types.ReviewMaxAggregateInput'] = None,
        having: Optional['types.ReviewScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReviewCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReviewScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReviewScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReviewGroupByOutput']:
        """Group Review records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Review fields to group records by
        where
            Review filter to select records
        take
            Limit the maximum number of Review records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReviewGroupByOutput]
            A list of dictionaries representing the Review record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Review records by exchangeId values
        # and count how many records are in each group
        results = await Review.prisma().group_by(
            ['exchangeId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SearchHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.SearchHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await SearchHistory.prisma().query_raw(
            'SELECT * FROM SearchHistory WHERE searchHistoryId = $1',
            1814397249,
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.SearchHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await SearchHistory.prisma().query_first(
            'SELECT * FROM SearchHistory WHERE userId = $1',
            1923090150,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SearchHistoryCreateInput,
        include: Optional[types.SearchHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new SearchHistory record.

        Parameters
        ----------
        data
            SearchHistory record data
        include
            Specifies which relations should be loaded on the returned SearchHistory model

        Returns
        -------
        prisma.models.SearchHistory
            The created SearchHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a SearchHistory record from just the required fields
        searchhistory = await SearchHistory.prisma().create(
            data={
                # data to create a SearchHistory record
                'userId': 1277244455,
                'searchQuery': 'bbgaifhdaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SearchHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple SearchHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of SearchHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await SearchHistory.prisma().create_many(
            data=[
                {
                    # data to create a SearchHistory record
                    'userId': 361230461,
                    'searchQuery': 'beagfbbjig',
                },
                {
                    # data to create a SearchHistory record
                    'userId': 1482877891,
                    'searchQuery': 'fgggcdcjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SearchHistoryWhereUniqueInput,
        include: Optional[types.SearchHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single SearchHistory record.

        Parameters
        ----------
        where
            SearchHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned SearchHistory model

        Returns
        -------
        prisma.models.SearchHistory
            The deleted SearchHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchhistory = await SearchHistory.prisma().delete(
            where={
                'searchHistoryId': 229119865,
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SearchHistoryWhereUniqueInput,
        include: Optional[types.SearchHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique SearchHistory record.

        Parameters
        ----------
        where
            SearchHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SearchHistory model

        Returns
        -------
        prisma.models.SearchHistory
            The found SearchHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchhistory = await SearchHistory.prisma().find_unique(
            where={
                'searchHistoryId': 1750011070,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SearchHistoryWhereUniqueInput,
        include: Optional[types.SearchHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique SearchHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            SearchHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned SearchHistory model

        Returns
        -------
        prisma.models.SearchHistory
            The found SearchHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchhistory = await SearchHistory.prisma().find_unique_or_raise(
            where={
                'searchHistoryId': 410943775,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchHistoryWhereInput] = None,
        cursor: Optional[types.SearchHistoryWhereUniqueInput] = None,
        include: Optional[types.SearchHistoryInclude] = None,
        order: Optional[Union[types.SearchHistoryOrderByInput, List[types.SearchHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.SearchHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple SearchHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of SearchHistory records returned
        skip
            Ignore the first N results
        where
            SearchHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SearchHistory model
        order
            Order the returned SearchHistory records by any field
        distinct
            Filter SearchHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.SearchHistory]
            The list of all SearchHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 SearchHistory records
        searchhistorys = await SearchHistory.prisma().find_many(take=10)

        # find the first 5 SearchHistory records ordered by the searchQuery field
        searchhistorys = await SearchHistory.prisma().find_many(
            take=5,
            order={
                'searchQuery': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SearchHistoryWhereInput] = None,
        cursor: Optional[types.SearchHistoryWhereUniqueInput] = None,
        include: Optional[types.SearchHistoryInclude] = None,
        order: Optional[Union[types.SearchHistoryOrderByInput, List[types.SearchHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.SearchHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single SearchHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SearchHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SearchHistory model
        order
            Order the returned SearchHistory records by any field
        distinct
            Filter SearchHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SearchHistory
            The first SearchHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SearchHistory record ordered by the searchedAt field
        searchhistory = await SearchHistory.prisma().find_first(
            skip=1,
            order={
                'searchedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SearchHistoryWhereInput] = None,
        cursor: Optional[types.SearchHistoryWhereUniqueInput] = None,
        include: Optional[types.SearchHistoryInclude] = None,
        order: Optional[Union[types.SearchHistoryOrderByInput, List[types.SearchHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.SearchHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single SearchHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            SearchHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned SearchHistory model
        order
            Order the returned SearchHistory records by any field
        distinct
            Filter SearchHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.SearchHistory
            The first SearchHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second SearchHistory record ordered by the numTimesSearched field
        searchhistory = await SearchHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'numTimesSearched': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SearchHistoryUpdateInput,
        where: types.SearchHistoryWhereUniqueInput,
        include: Optional[types.SearchHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single SearchHistory record.

        Parameters
        ----------
        data
            SearchHistory record data specifying what to update
        where
            SearchHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned SearchHistory model

        Returns
        -------
        prisma.models.SearchHistory
            The updated SearchHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        searchhistory = await SearchHistory.prisma().update(
            where={
                'searchHistoryId': 909024364,
            },
            data={
                # data to update the SearchHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SearchHistoryWhereUniqueInput,
        data: types.SearchHistoryUpsertInput,
        include: Optional[types.SearchHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            SearchHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned SearchHistory model

        Returns
        -------
        prisma.models.SearchHistory
            The created or updated SearchHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        searchhistory = await SearchHistory.prisma().upsert(
            where={
                'searchHistoryId': 755610165,
            },
            data={
                'create': {
                    'searchHistoryId': 755610165,
                    'userId': 1482877891,
                    'searchQuery': 'fgggcdcjg',
                },
                'update': {
                    'userId': 1482877891,
                    'searchQuery': 'fgggcdcjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SearchHistoryUpdateManyMutationInput,
        where: types.SearchHistoryWhereInput,
    ) -> int:
        """Update multiple SearchHistory records

        Parameters
        ----------
        data
            SearchHistory data to update the selected SearchHistory records to
        where
            Filter to select the SearchHistory records to update

        Returns
        -------
        int
            The total number of SearchHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all SearchHistory records
        total = await SearchHistory.prisma().update_many(
            data={
                'searchHistoryId': 1802188490
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchHistoryWhereInput] = None,
        cursor: Optional[types.SearchHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of SearchHistory records present in the database

        Parameters
        ----------
        select
            Select the SearchHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SearchHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SearchHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SearchHistory.prisma().count()

        # results: prisma.types.SearchHistoryCountAggregateOutput
        results = await SearchHistory.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SearchHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchHistoryWhereInput] = None,
        cursor: Optional[types.SearchHistoryWhereUniqueInput] = None,
    ) -> types.SearchHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SearchHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SearchHistoryWhereInput] = None,
        cursor: Optional[types.SearchHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.SearchHistoryCountAggregateOutput]:
        """Count the number of SearchHistory records present in the database

        Parameters
        ----------
        select
            Select the SearchHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            SearchHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SearchHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await SearchHistory.prisma().count()

        # results: prisma.types.SearchHistoryCountAggregateOutput
        results = await SearchHistory.prisma().count(
            select={
                '_all': True,
                'searchQuery': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SearchHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SearchHistoryWhereInput] = None
    ) -> int:
        """Delete multiple SearchHistory records.

        Parameters
        ----------
        where
            Optional SearchHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of SearchHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all SearchHistory records
        total = await SearchHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SearchHistoryScalarFieldKeys'],
        *,
        where: Optional['types.SearchHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SearchHistoryAvgAggregateInput'] = None,
        sum: Optional['types.SearchHistorySumAggregateInput'] = None,
        min: Optional['types.SearchHistoryMinAggregateInput'] = None,
        max: Optional['types.SearchHistoryMaxAggregateInput'] = None,
        having: Optional['types.SearchHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SearchHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SearchHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SearchHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SearchHistoryGroupByOutput']:
        """Group SearchHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar SearchHistory fields to group records by
        where
            SearchHistory filter to select records
        take
            Limit the maximum number of SearchHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SearchHistoryGroupByOutput]
            A list of dictionaries representing the SearchHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group SearchHistory records by searchedAt values
        # and count how many records are in each group
        results = await SearchHistory.prisma().group_by(
            ['searchedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models
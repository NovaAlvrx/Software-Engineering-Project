generator client {
    provider  = "prisma-client-py"
    interface = "asyncio"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model User {
    userId   Int    @id @default(autoincrement())
    fName    String
    lName    String
    email    String @unique
    password String
    role     Role   @default(USER)

    profile UserProfile? // Make sure to enforce the creation of User Profile in the frontend
}

enum Role {
    USER
    ADMIN
}

model UserProfile {
    userId           Int     @id
    profile_picture  String?
    general_location String?

    user User @relation(fields: [userId], references: [userId])

    posts            Post[]
    likes            Like[]
    comments         Comment[]
    skills           Skill[]
    targetSkills     TargetSkill[]

    sentMessages     Message[]      @relation("SenderMessages")
    receivedMessages Message[]      @relation("RecipientMessages")

    sentExchanges Exchange[]        @relation("sentExchanges") // need to double check 
    receivedExchanges Exchange[]    @relation("receivedExchanges") // need to double check

    reviewsGiven     Review[]       @relation("Reviewer")
    reviewsReceived  Review[]       @relation("Reviewee")

    searchHistories  SearchHistory[]
}

model Post {
    postId      Int      @id @default(autoincrement())
    userId      Int
    description String
    img         String
    createdAt   DateTime @default(now())

    user     UserProfile @relation(fields: [userId], references: [userId])
    likes    Like[]
    comments Comment[]

    @@unique([postId, userId])
}

model Like {
    likeId Int @id @default(autoincrement())
    postId Int
    userId Int

    post Post        @relation(fields: [postId], references: [postId])
    user UserProfile @relation(fields: [userId], references: [userId])

    @@unique([postId, userId]) // Ensure a user can like a post only once
}

model Comment {
    commentId Int      @id @default(autoincrement())
    postId    Int
    userId    Int
    content   String
    createdAt DateTime @default(now())

    post Post        @relation(fields: [postId], references: [postId])
    user UserProfile @relation(fields: [userId], references: [userId])
}

model Skill {
    skillId          Int     @id @default(autoincrement())
    userId           Int
    skillName        String
    skillDescription String
    skillValue       Int
    yearExperience   String

    user UserProfile @relation(fields: [userId], references: [userId])

    exchanges ExchangeSkill[]
}

model TargetSkill {
    targetSkillId Int    @id @default(autoincrement())
    userId        Int
    skillName     String

    user UserProfile @relation(fields: [userId], references: [userId])
}

model Conversation {
    id         Int      @id @default(autoincrement())
    messages   Message[] // holds the messages in this conversation
}

model Message {
    id        Int      @id @default(autoincrement()) // Each message has a unique id
    body      String
    sentAt    DateTime @default(now())

    senderId  Int
    sender   UserProfile @relation("SenderMessages", fields: [senderId], references: [userId])

    recipientId Int
    recipient   UserProfile @relation("RecipientMessages", fields: [recipientId], references: [userId])

    conversationId Int
    conversation   Conversation @relation(fields: [conversationId], references: [id])

    @@unique([id, senderId, recipientId, conversationId])
}

model Exchange {
    exchangeId   Int            @id @default(autoincrement())
    userOneId    Int
    userTwoId    Int

    sender       UserProfile @relation("sentExchanges", fields: [userOneId], references: [userId])
    receiver     UserProfile @relation("receivedExchanges", fields: [userTwoId], references: [userId])

    status       ExchangeStatus @default(PENDING)
    createdAt    DateTime       @default(now())

    @@unique([exchangeId, userOneId, userTwoId])

    exchangeSkills ExchangeSkill[]
    reviews Review[]
}

model ExchangeSkill {
    id         Int    @id @default(autoincrement())
    exchangeId Int
    skillId    Int

    exchange Exchange @relation(fields: [exchangeId], references: [exchangeId])
    skill    Skill    @relation(fields: [skillId], references: [skillId])

    @@unique([exchangeId, skillId])
}

enum ExchangeStatus {
    PENDING
    ACCEPTED
    DECLINED
    COMPLETED
}

model Review {
    reviewId       Int      @id @default(autoincrement())
    exchangeId     Int
    reviewerId     Int
    revieweeId     Int
    rating         Int
    description    String?
    createdAt      DateTime @default(now())

    exchange Exchange   @relation(fields: [exchangeId], references: [exchangeId])
    reviewer UserProfile @relation("Reviewer", fields: [reviewerId], references: [userId])
    reviewee UserProfile @relation("Reviewee", fields: [revieweeId], references: [userId])

    @@unique([reviewerId, revieweeId]) // Ensure a user can review another user only once
}

model SearchHistory { // Make sure to handle the logic in the API route
    searchHistoryId    Int      @id @default(autoincrement())
    userId             Int
    searchQuery        String
    searchedAt         DateTime @default(now())
    numTimesSearched   Int     @default(1)

    user UserProfile @relation(fields: [userId], references: [userId])

    @@unique([userId, searchQuery]) 
}